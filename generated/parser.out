Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN
    CONTEXT_OP
    COMP_OP
    DEFAULT
    PI

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement programme
Rule 3     programme -> statement ; programme
Rule 4     statement -> assignation
Rule 5     statement -> structure
Rule 6     statement -> BREAK
Rule 7     statement -> PRINT { expression }
Rule 8     condition -> expression EQUAL expression
Rule 9     condition -> expression NOTEQUAL expression
Rule 10    condition -> expression > expression
Rule 11    condition -> expression < expression
Rule 12    structure -> WHILE condition { programme }
Rule 13    structure -> LOOP { programme }
Rule 14    structure -> FOR expression TO expression STEP expression { programme }
Rule 15    structure -> IF condition { programme }
Rule 16    structure -> IF condition { programme } ELSE { programme }
Rule 17    structure -> SWITCH expression { programme }
Rule 18    structure -> CASE expression { programme }
Rule 19    expression -> expression ADD_OP expression
Rule 20    expression -> expression MUL_OP expression
Rule 21    expression -> IDENTIFIER
Rule 22    expression -> DIGIT
Rule 23    expression -> CHARACTERS
Rule 24    expression -> TRUE
Rule 25    expression -> FALSE
Rule 26    expression -> ( expression )
Rule 27    expression -> ADD_OP expression
Rule 28    type -> NUMBER
Rule 29    type -> BOOL
Rule 30    type -> TEXT
Rule 31    type -> LIST
Rule 32    assignation -> IDENTIFIER = expression
Rule 33    assignation -> BOOL IDENTIFIER = TRUE
Rule 34    assignation -> BOOL IDENTIFIER = FALSE
Rule 35    assignation -> NUMBER IDENTIFIER = DIGIT
Rule 36    assignation -> TEXT IDENTIFIER = CHARACTERS

Terminals, with rules where they appear

(                    : 26
)                    : 26
;                    : 3
<                    : 11
=                    : 32 33 34 35 36
>                    : 10
ADD_OP               : 19 27
BOOL                 : 29 33 34
BOOLEAN              : 
BREAK                : 6
CASE                 : 18
CHARACTERS           : 23 36
COMP_OP              : 
CONTEXT_OP           : 
DEFAULT              : 
DIGIT                : 22 35
ELSE                 : 16
EQUAL                : 8
FALSE                : 25 34
FOR                  : 14
IDENTIFIER           : 21 32 33 34 35 36
IF                   : 15 16
LIST                 : 31
LOOP                 : 13
MUL_OP               : 20
NOTEQUAL             : 9
NUMBER               : 28 35
PI                   : 
PRINT                : 7
STEP                 : 14
SWITCH               : 17
TEXT                 : 30 36
TO                   : 14
TRUE                 : 24 33
WHILE                : 12
error                : 
{                    : 7 12 13 14 15 16 16 17 18
}                    : 7 12 13 14 15 16 16 17 18

Nonterminals, with rules where they appear

assignation          : 4
condition            : 12 15 16
expression           : 7 8 8 9 9 10 10 11 11 14 14 14 17 18 19 19 20 20 26 27 32
programme            : 2 3 12 13 14 15 16 16 17 18 0
statement            : 1 2 3
structure            : 5
type                 : 

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . programme
    (3) programme -> statement . ; programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    ;               shift and go to state 18
    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    statement                      shift and go to state 2
    programme                      shift and go to state 17
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 3

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)
    BREAK           reduce using rule 4 (statement -> assignation .)
    PRINT           reduce using rule 4 (statement -> assignation .)
    IDENTIFIER      reduce using rule 4 (statement -> assignation .)
    BOOL            reduce using rule 4 (statement -> assignation .)
    NUMBER          reduce using rule 4 (statement -> assignation .)
    TEXT            reduce using rule 4 (statement -> assignation .)
    WHILE           reduce using rule 4 (statement -> assignation .)
    LOOP            reduce using rule 4 (statement -> assignation .)
    FOR             reduce using rule 4 (statement -> assignation .)
    IF              reduce using rule 4 (statement -> assignation .)
    SWITCH          reduce using rule 4 (statement -> assignation .)
    CASE            reduce using rule 4 (statement -> assignation .)
    $end            reduce using rule 4 (statement -> assignation .)
    }               reduce using rule 4 (statement -> assignation .)


state 4

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    BREAK           reduce using rule 5 (statement -> structure .)
    PRINT           reduce using rule 5 (statement -> structure .)
    IDENTIFIER      reduce using rule 5 (statement -> structure .)
    BOOL            reduce using rule 5 (statement -> structure .)
    NUMBER          reduce using rule 5 (statement -> structure .)
    TEXT            reduce using rule 5 (statement -> structure .)
    WHILE           reduce using rule 5 (statement -> structure .)
    LOOP            reduce using rule 5 (statement -> structure .)
    FOR             reduce using rule 5 (statement -> structure .)
    IF              reduce using rule 5 (statement -> structure .)
    SWITCH          reduce using rule 5 (statement -> structure .)
    CASE            reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 5

    (6) statement -> BREAK .

    ;               reduce using rule 6 (statement -> BREAK .)
    BREAK           reduce using rule 6 (statement -> BREAK .)
    PRINT           reduce using rule 6 (statement -> BREAK .)
    IDENTIFIER      reduce using rule 6 (statement -> BREAK .)
    BOOL            reduce using rule 6 (statement -> BREAK .)
    NUMBER          reduce using rule 6 (statement -> BREAK .)
    TEXT            reduce using rule 6 (statement -> BREAK .)
    WHILE           reduce using rule 6 (statement -> BREAK .)
    LOOP            reduce using rule 6 (statement -> BREAK .)
    FOR             reduce using rule 6 (statement -> BREAK .)
    IF              reduce using rule 6 (statement -> BREAK .)
    SWITCH          reduce using rule 6 (statement -> BREAK .)
    CASE            reduce using rule 6 (statement -> BREAK .)
    $end            reduce using rule 6 (statement -> BREAK .)
    }               reduce using rule 6 (statement -> BREAK .)


state 6

    (7) statement -> PRINT . { expression }

    {               shift and go to state 19


state 7

    (32) assignation -> IDENTIFIER . = expression

    =               shift and go to state 20


state 8

    (33) assignation -> BOOL . IDENTIFIER = TRUE
    (34) assignation -> BOOL . IDENTIFIER = FALSE

    IDENTIFIER      shift and go to state 21


state 9

    (35) assignation -> NUMBER . IDENTIFIER = DIGIT

    IDENTIFIER      shift and go to state 22


state 10

    (36) assignation -> TEXT . IDENTIFIER = CHARACTERS

    IDENTIFIER      shift and go to state 23


state 11

    (12) structure -> WHILE . condition { programme }
    (8) condition -> . expression EQUAL expression
    (9) condition -> . expression NOTEQUAL expression
    (10) condition -> . expression > expression
    (11) condition -> . expression < expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    condition                      shift and go to state 24
    expression                     shift and go to state 25

state 12

    (13) structure -> LOOP . { programme }

    {               shift and go to state 33


state 13

    (14) structure -> FOR . expression TO expression STEP expression { programme }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 34

state 14

    (15) structure -> IF . condition { programme }
    (16) structure -> IF . condition { programme } ELSE { programme }
    (8) condition -> . expression EQUAL expression
    (9) condition -> . expression NOTEQUAL expression
    (10) condition -> . expression > expression
    (11) condition -> . expression < expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    condition                      shift and go to state 35
    expression                     shift and go to state 25

state 15

    (17) structure -> SWITCH . expression { programme }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 36

state 16

    (18) structure -> CASE . expression { programme }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 37

state 17

    (2) programme -> statement programme .

    $end            reduce using rule 2 (programme -> statement programme .)
    }               reduce using rule 2 (programme -> statement programme .)


state 18

    (3) programme -> statement ; . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    statement                      shift and go to state 2
    programme                      shift and go to state 38
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 19

    (7) statement -> PRINT { . expression }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 39

state 20

    (32) assignation -> IDENTIFIER = . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 40

state 21

    (33) assignation -> BOOL IDENTIFIER . = TRUE
    (34) assignation -> BOOL IDENTIFIER . = FALSE

    =               shift and go to state 41


state 22

    (35) assignation -> NUMBER IDENTIFIER . = DIGIT

    =               shift and go to state 42


state 23

    (36) assignation -> TEXT IDENTIFIER . = CHARACTERS

    =               shift and go to state 43


state 24

    (12) structure -> WHILE condition . { programme }

    {               shift and go to state 44


state 25

    (8) condition -> expression . EQUAL expression
    (9) condition -> expression . NOTEQUAL expression
    (10) condition -> expression . > expression
    (11) condition -> expression . < expression
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    EQUAL           shift and go to state 45
    NOTEQUAL        shift and go to state 46
    >               shift and go to state 47
    <               shift and go to state 48
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 26

    (27) expression -> ADD_OP . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 51

state 27

    (21) expression -> IDENTIFIER .

    EQUAL           reduce using rule 21 (expression -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 21 (expression -> IDENTIFIER .)
    >               reduce using rule 21 (expression -> IDENTIFIER .)
    <               reduce using rule 21 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 21 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 21 (expression -> IDENTIFIER .)
    TO              reduce using rule 21 (expression -> IDENTIFIER .)
    {               reduce using rule 21 (expression -> IDENTIFIER .)
    }               reduce using rule 21 (expression -> IDENTIFIER .)
    ;               reduce using rule 21 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 21 (expression -> IDENTIFIER .)
    PRINT           reduce using rule 21 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (expression -> IDENTIFIER .)
    BOOL            reduce using rule 21 (expression -> IDENTIFIER .)
    NUMBER          reduce using rule 21 (expression -> IDENTIFIER .)
    TEXT            reduce using rule 21 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 21 (expression -> IDENTIFIER .)
    LOOP            reduce using rule 21 (expression -> IDENTIFIER .)
    FOR             reduce using rule 21 (expression -> IDENTIFIER .)
    IF              reduce using rule 21 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 21 (expression -> IDENTIFIER .)
    CASE            reduce using rule 21 (expression -> IDENTIFIER .)
    $end            reduce using rule 21 (expression -> IDENTIFIER .)
    )               reduce using rule 21 (expression -> IDENTIFIER .)
    STEP            reduce using rule 21 (expression -> IDENTIFIER .)


state 28

    (22) expression -> DIGIT .

    EQUAL           reduce using rule 22 (expression -> DIGIT .)
    NOTEQUAL        reduce using rule 22 (expression -> DIGIT .)
    >               reduce using rule 22 (expression -> DIGIT .)
    <               reduce using rule 22 (expression -> DIGIT .)
    ADD_OP          reduce using rule 22 (expression -> DIGIT .)
    MUL_OP          reduce using rule 22 (expression -> DIGIT .)
    TO              reduce using rule 22 (expression -> DIGIT .)
    {               reduce using rule 22 (expression -> DIGIT .)
    }               reduce using rule 22 (expression -> DIGIT .)
    ;               reduce using rule 22 (expression -> DIGIT .)
    BREAK           reduce using rule 22 (expression -> DIGIT .)
    PRINT           reduce using rule 22 (expression -> DIGIT .)
    IDENTIFIER      reduce using rule 22 (expression -> DIGIT .)
    BOOL            reduce using rule 22 (expression -> DIGIT .)
    NUMBER          reduce using rule 22 (expression -> DIGIT .)
    TEXT            reduce using rule 22 (expression -> DIGIT .)
    WHILE           reduce using rule 22 (expression -> DIGIT .)
    LOOP            reduce using rule 22 (expression -> DIGIT .)
    FOR             reduce using rule 22 (expression -> DIGIT .)
    IF              reduce using rule 22 (expression -> DIGIT .)
    SWITCH          reduce using rule 22 (expression -> DIGIT .)
    CASE            reduce using rule 22 (expression -> DIGIT .)
    $end            reduce using rule 22 (expression -> DIGIT .)
    )               reduce using rule 22 (expression -> DIGIT .)
    STEP            reduce using rule 22 (expression -> DIGIT .)


state 29

    (23) expression -> CHARACTERS .

    EQUAL           reduce using rule 23 (expression -> CHARACTERS .)
    NOTEQUAL        reduce using rule 23 (expression -> CHARACTERS .)
    >               reduce using rule 23 (expression -> CHARACTERS .)
    <               reduce using rule 23 (expression -> CHARACTERS .)
    ADD_OP          reduce using rule 23 (expression -> CHARACTERS .)
    MUL_OP          reduce using rule 23 (expression -> CHARACTERS .)
    TO              reduce using rule 23 (expression -> CHARACTERS .)
    {               reduce using rule 23 (expression -> CHARACTERS .)
    }               reduce using rule 23 (expression -> CHARACTERS .)
    ;               reduce using rule 23 (expression -> CHARACTERS .)
    BREAK           reduce using rule 23 (expression -> CHARACTERS .)
    PRINT           reduce using rule 23 (expression -> CHARACTERS .)
    IDENTIFIER      reduce using rule 23 (expression -> CHARACTERS .)
    BOOL            reduce using rule 23 (expression -> CHARACTERS .)
    NUMBER          reduce using rule 23 (expression -> CHARACTERS .)
    TEXT            reduce using rule 23 (expression -> CHARACTERS .)
    WHILE           reduce using rule 23 (expression -> CHARACTERS .)
    LOOP            reduce using rule 23 (expression -> CHARACTERS .)
    FOR             reduce using rule 23 (expression -> CHARACTERS .)
    IF              reduce using rule 23 (expression -> CHARACTERS .)
    SWITCH          reduce using rule 23 (expression -> CHARACTERS .)
    CASE            reduce using rule 23 (expression -> CHARACTERS .)
    $end            reduce using rule 23 (expression -> CHARACTERS .)
    )               reduce using rule 23 (expression -> CHARACTERS .)
    STEP            reduce using rule 23 (expression -> CHARACTERS .)


state 30

    (24) expression -> TRUE .

    EQUAL           reduce using rule 24 (expression -> TRUE .)
    NOTEQUAL        reduce using rule 24 (expression -> TRUE .)
    >               reduce using rule 24 (expression -> TRUE .)
    <               reduce using rule 24 (expression -> TRUE .)
    ADD_OP          reduce using rule 24 (expression -> TRUE .)
    MUL_OP          reduce using rule 24 (expression -> TRUE .)
    TO              reduce using rule 24 (expression -> TRUE .)
    {               reduce using rule 24 (expression -> TRUE .)
    }               reduce using rule 24 (expression -> TRUE .)
    ;               reduce using rule 24 (expression -> TRUE .)
    BREAK           reduce using rule 24 (expression -> TRUE .)
    PRINT           reduce using rule 24 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 24 (expression -> TRUE .)
    BOOL            reduce using rule 24 (expression -> TRUE .)
    NUMBER          reduce using rule 24 (expression -> TRUE .)
    TEXT            reduce using rule 24 (expression -> TRUE .)
    WHILE           reduce using rule 24 (expression -> TRUE .)
    LOOP            reduce using rule 24 (expression -> TRUE .)
    FOR             reduce using rule 24 (expression -> TRUE .)
    IF              reduce using rule 24 (expression -> TRUE .)
    SWITCH          reduce using rule 24 (expression -> TRUE .)
    CASE            reduce using rule 24 (expression -> TRUE .)
    $end            reduce using rule 24 (expression -> TRUE .)
    )               reduce using rule 24 (expression -> TRUE .)
    STEP            reduce using rule 24 (expression -> TRUE .)


state 31

    (25) expression -> FALSE .

    EQUAL           reduce using rule 25 (expression -> FALSE .)
    NOTEQUAL        reduce using rule 25 (expression -> FALSE .)
    >               reduce using rule 25 (expression -> FALSE .)
    <               reduce using rule 25 (expression -> FALSE .)
    ADD_OP          reduce using rule 25 (expression -> FALSE .)
    MUL_OP          reduce using rule 25 (expression -> FALSE .)
    TO              reduce using rule 25 (expression -> FALSE .)
    {               reduce using rule 25 (expression -> FALSE .)
    }               reduce using rule 25 (expression -> FALSE .)
    ;               reduce using rule 25 (expression -> FALSE .)
    BREAK           reduce using rule 25 (expression -> FALSE .)
    PRINT           reduce using rule 25 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 25 (expression -> FALSE .)
    BOOL            reduce using rule 25 (expression -> FALSE .)
    NUMBER          reduce using rule 25 (expression -> FALSE .)
    TEXT            reduce using rule 25 (expression -> FALSE .)
    WHILE           reduce using rule 25 (expression -> FALSE .)
    LOOP            reduce using rule 25 (expression -> FALSE .)
    FOR             reduce using rule 25 (expression -> FALSE .)
    IF              reduce using rule 25 (expression -> FALSE .)
    SWITCH          reduce using rule 25 (expression -> FALSE .)
    CASE            reduce using rule 25 (expression -> FALSE .)
    $end            reduce using rule 25 (expression -> FALSE .)
    )               reduce using rule 25 (expression -> FALSE .)
    STEP            reduce using rule 25 (expression -> FALSE .)


state 32

    (26) expression -> ( . expression )
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 52

state 33

    (13) structure -> LOOP { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 53
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 34

    (14) structure -> FOR expression . TO expression STEP expression { programme }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    TO              shift and go to state 54
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 35

    (15) structure -> IF condition . { programme }
    (16) structure -> IF condition . { programme } ELSE { programme }

    {               shift and go to state 55


state 36

    (17) structure -> SWITCH expression . { programme }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               shift and go to state 56
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 37

    (18) structure -> CASE expression . { programme }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               shift and go to state 57
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 38

    (3) programme -> statement ; programme .

    $end            reduce using rule 3 (programme -> statement ; programme .)
    }               reduce using rule 3 (programme -> statement ; programme .)


state 39

    (7) statement -> PRINT { expression . }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    }               shift and go to state 58
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 40

    (32) assignation -> IDENTIFIER = expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    ;               reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    BREAK           reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    PRINT           reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    IDENTIFIER      reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    BOOL            reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    NUMBER          reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    TEXT            reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    WHILE           reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    LOOP            reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    FOR             reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    IF              reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    SWITCH          reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    CASE            reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 32 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 41

    (33) assignation -> BOOL IDENTIFIER = . TRUE
    (34) assignation -> BOOL IDENTIFIER = . FALSE

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60


state 42

    (35) assignation -> NUMBER IDENTIFIER = . DIGIT

    DIGIT           shift and go to state 61


state 43

    (36) assignation -> TEXT IDENTIFIER = . CHARACTERS

    CHARACTERS      shift and go to state 62


state 44

    (12) structure -> WHILE condition { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 63
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 45

    (8) condition -> expression EQUAL . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 64

state 46

    (9) condition -> expression NOTEQUAL . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 65

state 47

    (10) condition -> expression > . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 66

state 48

    (11) condition -> expression < . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 67

state 49

    (19) expression -> expression ADD_OP . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 68

state 50

    (20) expression -> expression MUL_OP . expression
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 69

state 51

    (27) expression -> ADD_OP expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 27 (expression -> ADD_OP expression .)
    NOTEQUAL        reduce using rule 27 (expression -> ADD_OP expression .)
    >               reduce using rule 27 (expression -> ADD_OP expression .)
    <               reduce using rule 27 (expression -> ADD_OP expression .)
    ADD_OP          reduce using rule 27 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 27 (expression -> ADD_OP expression .)
    TO              reduce using rule 27 (expression -> ADD_OP expression .)
    {               reduce using rule 27 (expression -> ADD_OP expression .)
    }               reduce using rule 27 (expression -> ADD_OP expression .)
    ;               reduce using rule 27 (expression -> ADD_OP expression .)
    BREAK           reduce using rule 27 (expression -> ADD_OP expression .)
    PRINT           reduce using rule 27 (expression -> ADD_OP expression .)
    IDENTIFIER      reduce using rule 27 (expression -> ADD_OP expression .)
    BOOL            reduce using rule 27 (expression -> ADD_OP expression .)
    NUMBER          reduce using rule 27 (expression -> ADD_OP expression .)
    TEXT            reduce using rule 27 (expression -> ADD_OP expression .)
    WHILE           reduce using rule 27 (expression -> ADD_OP expression .)
    LOOP            reduce using rule 27 (expression -> ADD_OP expression .)
    FOR             reduce using rule 27 (expression -> ADD_OP expression .)
    IF              reduce using rule 27 (expression -> ADD_OP expression .)
    SWITCH          reduce using rule 27 (expression -> ADD_OP expression .)
    CASE            reduce using rule 27 (expression -> ADD_OP expression .)
    $end            reduce using rule 27 (expression -> ADD_OP expression .)
    )               reduce using rule 27 (expression -> ADD_OP expression .)
    STEP            reduce using rule 27 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 49 ]
  ! MUL_OP          [ shift and go to state 50 ]


state 52

    (26) expression -> ( expression . )
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    )               shift and go to state 70
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 53

    (13) structure -> LOOP { programme . }

    }               shift and go to state 71


state 54

    (14) structure -> FOR expression TO . expression STEP expression { programme }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 72

state 55

    (15) structure -> IF condition { . programme }
    (16) structure -> IF condition { . programme } ELSE { programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 73
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 56

    (17) structure -> SWITCH expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 74
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 57

    (18) structure -> CASE expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 75
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 58

    (7) statement -> PRINT { expression } .

    ;               reduce using rule 7 (statement -> PRINT { expression } .)
    BREAK           reduce using rule 7 (statement -> PRINT { expression } .)
    PRINT           reduce using rule 7 (statement -> PRINT { expression } .)
    IDENTIFIER      reduce using rule 7 (statement -> PRINT { expression } .)
    BOOL            reduce using rule 7 (statement -> PRINT { expression } .)
    NUMBER          reduce using rule 7 (statement -> PRINT { expression } .)
    TEXT            reduce using rule 7 (statement -> PRINT { expression } .)
    WHILE           reduce using rule 7 (statement -> PRINT { expression } .)
    LOOP            reduce using rule 7 (statement -> PRINT { expression } .)
    FOR             reduce using rule 7 (statement -> PRINT { expression } .)
    IF              reduce using rule 7 (statement -> PRINT { expression } .)
    SWITCH          reduce using rule 7 (statement -> PRINT { expression } .)
    CASE            reduce using rule 7 (statement -> PRINT { expression } .)
    $end            reduce using rule 7 (statement -> PRINT { expression } .)
    }               reduce using rule 7 (statement -> PRINT { expression } .)


state 59

    (33) assignation -> BOOL IDENTIFIER = TRUE .

    ;               reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    BREAK           reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    PRINT           reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    IDENTIFIER      reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    BOOL            reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    NUMBER          reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    TEXT            reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    WHILE           reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    LOOP            reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    FOR             reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    IF              reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    SWITCH          reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    CASE            reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    $end            reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)
    }               reduce using rule 33 (assignation -> BOOL IDENTIFIER = TRUE .)


state 60

    (34) assignation -> BOOL IDENTIFIER = FALSE .

    ;               reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    BREAK           reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    PRINT           reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    IDENTIFIER      reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    BOOL            reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    NUMBER          reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    TEXT            reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    WHILE           reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    LOOP            reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    FOR             reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    IF              reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    SWITCH          reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    CASE            reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    $end            reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)
    }               reduce using rule 34 (assignation -> BOOL IDENTIFIER = FALSE .)


state 61

    (35) assignation -> NUMBER IDENTIFIER = DIGIT .

    ;               reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    BREAK           reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    PRINT           reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    IDENTIFIER      reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    BOOL            reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    NUMBER          reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    TEXT            reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    WHILE           reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    LOOP            reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    FOR             reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    IF              reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    SWITCH          reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    CASE            reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    $end            reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    }               reduce using rule 35 (assignation -> NUMBER IDENTIFIER = DIGIT .)


state 62

    (36) assignation -> TEXT IDENTIFIER = CHARACTERS .

    ;               reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    BREAK           reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    PRINT           reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    IDENTIFIER      reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    BOOL            reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    NUMBER          reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    TEXT            reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    WHILE           reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    LOOP            reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    FOR             reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    IF              reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    SWITCH          reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    CASE            reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    $end            reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    }               reduce using rule 36 (assignation -> TEXT IDENTIFIER = CHARACTERS .)


state 63

    (12) structure -> WHILE condition { programme . }

    }               shift and go to state 76


state 64

    (8) condition -> expression EQUAL expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               reduce using rule 8 (condition -> expression EQUAL expression .)
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 65

    (9) condition -> expression NOTEQUAL expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               reduce using rule 9 (condition -> expression NOTEQUAL expression .)
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 66

    (10) condition -> expression > expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               reduce using rule 10 (condition -> expression > expression .)
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 67

    (11) condition -> expression < expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               reduce using rule 11 (condition -> expression < expression .)
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 68

    (19) expression -> expression ADD_OP expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 19 (expression -> expression ADD_OP expression .)
    NOTEQUAL        reduce using rule 19 (expression -> expression ADD_OP expression .)
    >               reduce using rule 19 (expression -> expression ADD_OP expression .)
    <               reduce using rule 19 (expression -> expression ADD_OP expression .)
    ADD_OP          reduce using rule 19 (expression -> expression ADD_OP expression .)
    TO              reduce using rule 19 (expression -> expression ADD_OP expression .)
    {               reduce using rule 19 (expression -> expression ADD_OP expression .)
    }               reduce using rule 19 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 19 (expression -> expression ADD_OP expression .)
    BREAK           reduce using rule 19 (expression -> expression ADD_OP expression .)
    PRINT           reduce using rule 19 (expression -> expression ADD_OP expression .)
    IDENTIFIER      reduce using rule 19 (expression -> expression ADD_OP expression .)
    BOOL            reduce using rule 19 (expression -> expression ADD_OP expression .)
    NUMBER          reduce using rule 19 (expression -> expression ADD_OP expression .)
    TEXT            reduce using rule 19 (expression -> expression ADD_OP expression .)
    WHILE           reduce using rule 19 (expression -> expression ADD_OP expression .)
    LOOP            reduce using rule 19 (expression -> expression ADD_OP expression .)
    FOR             reduce using rule 19 (expression -> expression ADD_OP expression .)
    IF              reduce using rule 19 (expression -> expression ADD_OP expression .)
    SWITCH          reduce using rule 19 (expression -> expression ADD_OP expression .)
    CASE            reduce using rule 19 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 19 (expression -> expression ADD_OP expression .)
    )               reduce using rule 19 (expression -> expression ADD_OP expression .)
    STEP            reduce using rule 19 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 50

  ! MUL_OP          [ reduce using rule 19 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 49 ]


state 69

    (20) expression -> expression MUL_OP expression .
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 20 (expression -> expression MUL_OP expression .)
    NOTEQUAL        reduce using rule 20 (expression -> expression MUL_OP expression .)
    >               reduce using rule 20 (expression -> expression MUL_OP expression .)
    <               reduce using rule 20 (expression -> expression MUL_OP expression .)
    ADD_OP          reduce using rule 20 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 20 (expression -> expression MUL_OP expression .)
    TO              reduce using rule 20 (expression -> expression MUL_OP expression .)
    {               reduce using rule 20 (expression -> expression MUL_OP expression .)
    }               reduce using rule 20 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 20 (expression -> expression MUL_OP expression .)
    BREAK           reduce using rule 20 (expression -> expression MUL_OP expression .)
    PRINT           reduce using rule 20 (expression -> expression MUL_OP expression .)
    IDENTIFIER      reduce using rule 20 (expression -> expression MUL_OP expression .)
    BOOL            reduce using rule 20 (expression -> expression MUL_OP expression .)
    NUMBER          reduce using rule 20 (expression -> expression MUL_OP expression .)
    TEXT            reduce using rule 20 (expression -> expression MUL_OP expression .)
    WHILE           reduce using rule 20 (expression -> expression MUL_OP expression .)
    LOOP            reduce using rule 20 (expression -> expression MUL_OP expression .)
    FOR             reduce using rule 20 (expression -> expression MUL_OP expression .)
    IF              reduce using rule 20 (expression -> expression MUL_OP expression .)
    SWITCH          reduce using rule 20 (expression -> expression MUL_OP expression .)
    CASE            reduce using rule 20 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 20 (expression -> expression MUL_OP expression .)
    )               reduce using rule 20 (expression -> expression MUL_OP expression .)
    STEP            reduce using rule 20 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 49 ]
  ! MUL_OP          [ shift and go to state 50 ]


state 70

    (26) expression -> ( expression ) .

    EQUAL           reduce using rule 26 (expression -> ( expression ) .)
    NOTEQUAL        reduce using rule 26 (expression -> ( expression ) .)
    >               reduce using rule 26 (expression -> ( expression ) .)
    <               reduce using rule 26 (expression -> ( expression ) .)
    ADD_OP          reduce using rule 26 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 26 (expression -> ( expression ) .)
    TO              reduce using rule 26 (expression -> ( expression ) .)
    {               reduce using rule 26 (expression -> ( expression ) .)
    }               reduce using rule 26 (expression -> ( expression ) .)
    ;               reduce using rule 26 (expression -> ( expression ) .)
    BREAK           reduce using rule 26 (expression -> ( expression ) .)
    PRINT           reduce using rule 26 (expression -> ( expression ) .)
    IDENTIFIER      reduce using rule 26 (expression -> ( expression ) .)
    BOOL            reduce using rule 26 (expression -> ( expression ) .)
    NUMBER          reduce using rule 26 (expression -> ( expression ) .)
    TEXT            reduce using rule 26 (expression -> ( expression ) .)
    WHILE           reduce using rule 26 (expression -> ( expression ) .)
    LOOP            reduce using rule 26 (expression -> ( expression ) .)
    FOR             reduce using rule 26 (expression -> ( expression ) .)
    IF              reduce using rule 26 (expression -> ( expression ) .)
    SWITCH          reduce using rule 26 (expression -> ( expression ) .)
    CASE            reduce using rule 26 (expression -> ( expression ) .)
    $end            reduce using rule 26 (expression -> ( expression ) .)
    )               reduce using rule 26 (expression -> ( expression ) .)
    STEP            reduce using rule 26 (expression -> ( expression ) .)


state 71

    (13) structure -> LOOP { programme } .

    ;               reduce using rule 13 (structure -> LOOP { programme } .)
    BREAK           reduce using rule 13 (structure -> LOOP { programme } .)
    PRINT           reduce using rule 13 (structure -> LOOP { programme } .)
    IDENTIFIER      reduce using rule 13 (structure -> LOOP { programme } .)
    BOOL            reduce using rule 13 (structure -> LOOP { programme } .)
    NUMBER          reduce using rule 13 (structure -> LOOP { programme } .)
    TEXT            reduce using rule 13 (structure -> LOOP { programme } .)
    WHILE           reduce using rule 13 (structure -> LOOP { programme } .)
    LOOP            reduce using rule 13 (structure -> LOOP { programme } .)
    FOR             reduce using rule 13 (structure -> LOOP { programme } .)
    IF              reduce using rule 13 (structure -> LOOP { programme } .)
    SWITCH          reduce using rule 13 (structure -> LOOP { programme } .)
    CASE            reduce using rule 13 (structure -> LOOP { programme } .)
    $end            reduce using rule 13 (structure -> LOOP { programme } .)
    }               reduce using rule 13 (structure -> LOOP { programme } .)


state 72

    (14) structure -> FOR expression TO expression . STEP expression { programme }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    STEP            shift and go to state 77
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 73

    (15) structure -> IF condition { programme . }
    (16) structure -> IF condition { programme . } ELSE { programme }

    }               shift and go to state 78


state 74

    (17) structure -> SWITCH expression { programme . }

    }               shift and go to state 79


state 75

    (18) structure -> CASE expression { programme . }

    }               shift and go to state 80


state 76

    (12) structure -> WHILE condition { programme } .

    ;               reduce using rule 12 (structure -> WHILE condition { programme } .)
    BREAK           reduce using rule 12 (structure -> WHILE condition { programme } .)
    PRINT           reduce using rule 12 (structure -> WHILE condition { programme } .)
    IDENTIFIER      reduce using rule 12 (structure -> WHILE condition { programme } .)
    BOOL            reduce using rule 12 (structure -> WHILE condition { programme } .)
    NUMBER          reduce using rule 12 (structure -> WHILE condition { programme } .)
    TEXT            reduce using rule 12 (structure -> WHILE condition { programme } .)
    WHILE           reduce using rule 12 (structure -> WHILE condition { programme } .)
    LOOP            reduce using rule 12 (structure -> WHILE condition { programme } .)
    FOR             reduce using rule 12 (structure -> WHILE condition { programme } .)
    IF              reduce using rule 12 (structure -> WHILE condition { programme } .)
    SWITCH          reduce using rule 12 (structure -> WHILE condition { programme } .)
    CASE            reduce using rule 12 (structure -> WHILE condition { programme } .)
    $end            reduce using rule 12 (structure -> WHILE condition { programme } .)
    }               reduce using rule 12 (structure -> WHILE condition { programme } .)


state 77

    (14) structure -> FOR expression TO expression STEP . expression { programme }
    (19) expression -> . expression ADD_OP expression
    (20) expression -> . expression MUL_OP expression
    (21) expression -> . IDENTIFIER
    (22) expression -> . DIGIT
    (23) expression -> . CHARACTERS
    (24) expression -> . TRUE
    (25) expression -> . FALSE
    (26) expression -> . ( expression )
    (27) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 27
    DIGIT           shift and go to state 28
    CHARACTERS      shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    (               shift and go to state 32
    ADD_OP          shift and go to state 26

    expression                     shift and go to state 81

state 78

    (15) structure -> IF condition { programme } .
    (16) structure -> IF condition { programme } . ELSE { programme }

    ;               reduce using rule 15 (structure -> IF condition { programme } .)
    BREAK           reduce using rule 15 (structure -> IF condition { programme } .)
    PRINT           reduce using rule 15 (structure -> IF condition { programme } .)
    IDENTIFIER      reduce using rule 15 (structure -> IF condition { programme } .)
    BOOL            reduce using rule 15 (structure -> IF condition { programme } .)
    NUMBER          reduce using rule 15 (structure -> IF condition { programme } .)
    TEXT            reduce using rule 15 (structure -> IF condition { programme } .)
    WHILE           reduce using rule 15 (structure -> IF condition { programme } .)
    LOOP            reduce using rule 15 (structure -> IF condition { programme } .)
    FOR             reduce using rule 15 (structure -> IF condition { programme } .)
    IF              reduce using rule 15 (structure -> IF condition { programme } .)
    SWITCH          reduce using rule 15 (structure -> IF condition { programme } .)
    CASE            reduce using rule 15 (structure -> IF condition { programme } .)
    $end            reduce using rule 15 (structure -> IF condition { programme } .)
    }               reduce using rule 15 (structure -> IF condition { programme } .)
    ELSE            shift and go to state 82


state 79

    (17) structure -> SWITCH expression { programme } .

    ;               reduce using rule 17 (structure -> SWITCH expression { programme } .)
    BREAK           reduce using rule 17 (structure -> SWITCH expression { programme } .)
    PRINT           reduce using rule 17 (structure -> SWITCH expression { programme } .)
    IDENTIFIER      reduce using rule 17 (structure -> SWITCH expression { programme } .)
    BOOL            reduce using rule 17 (structure -> SWITCH expression { programme } .)
    NUMBER          reduce using rule 17 (structure -> SWITCH expression { programme } .)
    TEXT            reduce using rule 17 (structure -> SWITCH expression { programme } .)
    WHILE           reduce using rule 17 (structure -> SWITCH expression { programme } .)
    LOOP            reduce using rule 17 (structure -> SWITCH expression { programme } .)
    FOR             reduce using rule 17 (structure -> SWITCH expression { programme } .)
    IF              reduce using rule 17 (structure -> SWITCH expression { programme } .)
    SWITCH          reduce using rule 17 (structure -> SWITCH expression { programme } .)
    CASE            reduce using rule 17 (structure -> SWITCH expression { programme } .)
    $end            reduce using rule 17 (structure -> SWITCH expression { programme } .)
    }               reduce using rule 17 (structure -> SWITCH expression { programme } .)


state 80

    (18) structure -> CASE expression { programme } .

    ;               reduce using rule 18 (structure -> CASE expression { programme } .)
    BREAK           reduce using rule 18 (structure -> CASE expression { programme } .)
    PRINT           reduce using rule 18 (structure -> CASE expression { programme } .)
    IDENTIFIER      reduce using rule 18 (structure -> CASE expression { programme } .)
    BOOL            reduce using rule 18 (structure -> CASE expression { programme } .)
    NUMBER          reduce using rule 18 (structure -> CASE expression { programme } .)
    TEXT            reduce using rule 18 (structure -> CASE expression { programme } .)
    WHILE           reduce using rule 18 (structure -> CASE expression { programme } .)
    LOOP            reduce using rule 18 (structure -> CASE expression { programme } .)
    FOR             reduce using rule 18 (structure -> CASE expression { programme } .)
    IF              reduce using rule 18 (structure -> CASE expression { programme } .)
    SWITCH          reduce using rule 18 (structure -> CASE expression { programme } .)
    CASE            reduce using rule 18 (structure -> CASE expression { programme } .)
    $end            reduce using rule 18 (structure -> CASE expression { programme } .)
    }               reduce using rule 18 (structure -> CASE expression { programme } .)


state 81

    (14) structure -> FOR expression TO expression STEP expression . { programme }
    (19) expression -> expression . ADD_OP expression
    (20) expression -> expression . MUL_OP expression

    {               shift and go to state 83
    ADD_OP          shift and go to state 49
    MUL_OP          shift and go to state 50


state 82

    (16) structure -> IF condition { programme } ELSE . { programme }

    {               shift and go to state 84


state 83

    (14) structure -> FOR expression TO expression STEP expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 85
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 84

    (16) structure -> IF condition { programme } ELSE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) programme -> . statement ; programme
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . BREAK
    (7) statement -> . PRINT { expression }
    (32) assignation -> . IDENTIFIER = expression
    (33) assignation -> . BOOL IDENTIFIER = TRUE
    (34) assignation -> . BOOL IDENTIFIER = FALSE
    (35) assignation -> . NUMBER IDENTIFIER = DIGIT
    (36) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (12) structure -> . WHILE condition { programme }
    (13) structure -> . LOOP { programme }
    (14) structure -> . FOR expression TO expression STEP expression { programme }
    (15) structure -> . IF condition { programme }
    (16) structure -> . IF condition { programme } ELSE { programme }
    (17) structure -> . SWITCH expression { programme }
    (18) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 86
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 85

    (14) structure -> FOR expression TO expression STEP expression { programme . }

    }               shift and go to state 87


state 86

    (16) structure -> IF condition { programme } ELSE { programme . }

    }               shift and go to state 88


state 87

    (14) structure -> FOR expression TO expression STEP expression { programme } .

    ;               reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    BREAK           reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    PRINT           reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    IDENTIFIER      reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    BOOL            reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    NUMBER          reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    TEXT            reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    WHILE           reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    LOOP            reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    FOR             reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    IF              reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    SWITCH          reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    CASE            reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    $end            reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)
    }               reduce using rule 14 (structure -> FOR expression TO expression STEP expression { programme } .)


state 88

    (16) structure -> IF condition { programme } ELSE { programme } .

    ;               reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    BREAK           reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    PRINT           reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    IDENTIFIER      reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    BOOL            reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    NUMBER          reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    TEXT            reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    WHILE           reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    LOOP            reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    FOR             reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    IF              reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    SWITCH          reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    CASE            reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    $end            reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)
    }               reduce using rule 16 (structure -> IF condition { programme } ELSE { programme } .)

