Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    CONTEXT_OP
    COMP_OP
    DEFAULT
    PI
    TRUE
    FALSE
    LIST

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement programme
Rule 3     statement -> assignation
Rule 4     statement -> structure
Rule 5     statement -> BREAK
Rule 6     statement -> PRINT { expression }
Rule 7     condition -> expression EQUAL expression
Rule 8     condition -> expression NOTEQUAL expression
Rule 9     condition -> expression > expression
Rule 10    condition -> expression < expression
Rule 11    structure -> WHILE condition { programme }
Rule 12    structure -> LOOP { programme }
Rule 13    structure -> FOR expression TO expression STEP expression { programme }
Rule 14    structure -> IF condition { programme }
Rule 15    structure -> IF condition { programme } ELSE { programme }
Rule 16    structure -> SWITCH expression { programme }
Rule 17    structure -> CASE expression { programme }
Rule 18    expression -> expression ADD_OP expression
Rule 19    expression -> expression MUL_OP expression
Rule 20    expression -> IDENTIFIER
Rule 21    expression -> DIGIT
Rule 22    expression -> CHARACTERS
Rule 23    expression -> BOOLEAN
Rule 24    expression -> ( expression )
Rule 25    expression -> ADD_OP expression
Rule 26    assignation -> IDENTIFIER = expression
Rule 27    assignation -> BOOL IDENTIFIER = expression
Rule 28    assignation -> NUMBER IDENTIFIER = DIGIT
Rule 29    assignation -> TEXT IDENTIFIER = CHARACTERS

Terminals, with rules where they appear

(                    : 24
)                    : 24
<                    : 10
=                    : 26 27 28 29
>                    : 9
ADD_OP               : 18 25
BOOL                 : 27
BOOLEAN              : 23
BREAK                : 5
CASE                 : 17
CHARACTERS           : 22 29
COMP_OP              : 
CONTEXT_OP           : 
DEFAULT              : 
DIGIT                : 21 28
ELSE                 : 15
EQUAL                : 7
FALSE                : 
FOR                  : 13
IDENTIFIER           : 20 26 27 28 29
IF                   : 14 15
LIST                 : 
LOOP                 : 12
MUL_OP               : 19
NOTEQUAL             : 8
NUMBER               : 28
PI                   : 
PRINT                : 6
STEP                 : 13
SWITCH               : 16
TEXT                 : 29
TO                   : 13
TRUE                 : 
WHILE                : 11
error                : 
{                    : 6 11 12 13 14 15 15 16 17
}                    : 6 11 12 13 14 15 15 16 17

Nonterminals, with rules where they appear

assignation          : 3
condition            : 11 14 15
expression           : 6 7 7 8 8 9 9 10 10 13 13 13 16 17 18 18 19 19 24 25 26 27
programme            : 2 11 12 13 14 15 15 16 17 0
statement            : 1 2
structure            : 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    statement                      shift and go to state 2
    programme                      shift and go to state 17
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 3

    (3) statement -> assignation .

    BREAK           reduce using rule 3 (statement -> assignation .)
    PRINT           reduce using rule 3 (statement -> assignation .)
    IDENTIFIER      reduce using rule 3 (statement -> assignation .)
    BOOL            reduce using rule 3 (statement -> assignation .)
    NUMBER          reduce using rule 3 (statement -> assignation .)
    TEXT            reduce using rule 3 (statement -> assignation .)
    WHILE           reduce using rule 3 (statement -> assignation .)
    LOOP            reduce using rule 3 (statement -> assignation .)
    FOR             reduce using rule 3 (statement -> assignation .)
    IF              reduce using rule 3 (statement -> assignation .)
    SWITCH          reduce using rule 3 (statement -> assignation .)
    CASE            reduce using rule 3 (statement -> assignation .)
    $end            reduce using rule 3 (statement -> assignation .)
    }               reduce using rule 3 (statement -> assignation .)


state 4

    (4) statement -> structure .

    BREAK           reduce using rule 4 (statement -> structure .)
    PRINT           reduce using rule 4 (statement -> structure .)
    IDENTIFIER      reduce using rule 4 (statement -> structure .)
    BOOL            reduce using rule 4 (statement -> structure .)
    NUMBER          reduce using rule 4 (statement -> structure .)
    TEXT            reduce using rule 4 (statement -> structure .)
    WHILE           reduce using rule 4 (statement -> structure .)
    LOOP            reduce using rule 4 (statement -> structure .)
    FOR             reduce using rule 4 (statement -> structure .)
    IF              reduce using rule 4 (statement -> structure .)
    SWITCH          reduce using rule 4 (statement -> structure .)
    CASE            reduce using rule 4 (statement -> structure .)
    $end            reduce using rule 4 (statement -> structure .)
    }               reduce using rule 4 (statement -> structure .)


state 5

    (5) statement -> BREAK .

    BREAK           reduce using rule 5 (statement -> BREAK .)
    PRINT           reduce using rule 5 (statement -> BREAK .)
    IDENTIFIER      reduce using rule 5 (statement -> BREAK .)
    BOOL            reduce using rule 5 (statement -> BREAK .)
    NUMBER          reduce using rule 5 (statement -> BREAK .)
    TEXT            reduce using rule 5 (statement -> BREAK .)
    WHILE           reduce using rule 5 (statement -> BREAK .)
    LOOP            reduce using rule 5 (statement -> BREAK .)
    FOR             reduce using rule 5 (statement -> BREAK .)
    IF              reduce using rule 5 (statement -> BREAK .)
    SWITCH          reduce using rule 5 (statement -> BREAK .)
    CASE            reduce using rule 5 (statement -> BREAK .)
    $end            reduce using rule 5 (statement -> BREAK .)
    }               reduce using rule 5 (statement -> BREAK .)


state 6

    (6) statement -> PRINT . { expression }

    {               shift and go to state 18


state 7

    (26) assignation -> IDENTIFIER . = expression

    =               shift and go to state 19


state 8

    (27) assignation -> BOOL . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 20


state 9

    (28) assignation -> NUMBER . IDENTIFIER = DIGIT

    IDENTIFIER      shift and go to state 21


state 10

    (29) assignation -> TEXT . IDENTIFIER = CHARACTERS

    IDENTIFIER      shift and go to state 22


state 11

    (11) structure -> WHILE . condition { programme }
    (7) condition -> . expression EQUAL expression
    (8) condition -> . expression NOTEQUAL expression
    (9) condition -> . expression > expression
    (10) condition -> . expression < expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    condition                      shift and go to state 23
    expression                     shift and go to state 24

state 12

    (12) structure -> LOOP . { programme }

    {               shift and go to state 31


state 13

    (13) structure -> FOR . expression TO expression STEP expression { programme }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 32

state 14

    (14) structure -> IF . condition { programme }
    (15) structure -> IF . condition { programme } ELSE { programme }
    (7) condition -> . expression EQUAL expression
    (8) condition -> . expression NOTEQUAL expression
    (9) condition -> . expression > expression
    (10) condition -> . expression < expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    condition                      shift and go to state 33
    expression                     shift and go to state 24

state 15

    (16) structure -> SWITCH . expression { programme }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 34

state 16

    (17) structure -> CASE . expression { programme }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 35

state 17

    (2) programme -> statement programme .

    $end            reduce using rule 2 (programme -> statement programme .)
    }               reduce using rule 2 (programme -> statement programme .)


state 18

    (6) statement -> PRINT { . expression }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 36

state 19

    (26) assignation -> IDENTIFIER = . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 37

state 20

    (27) assignation -> BOOL IDENTIFIER . = expression

    =               shift and go to state 38


state 21

    (28) assignation -> NUMBER IDENTIFIER . = DIGIT

    =               shift and go to state 39


state 22

    (29) assignation -> TEXT IDENTIFIER . = CHARACTERS

    =               shift and go to state 40


state 23

    (11) structure -> WHILE condition . { programme }

    {               shift and go to state 41


state 24

    (7) condition -> expression . EQUAL expression
    (8) condition -> expression . NOTEQUAL expression
    (9) condition -> expression . > expression
    (10) condition -> expression . < expression
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    EQUAL           shift and go to state 42
    NOTEQUAL        shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 25

    (25) expression -> ADD_OP . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 48

state 26

    (20) expression -> IDENTIFIER .

    EQUAL           reduce using rule 20 (expression -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 20 (expression -> IDENTIFIER .)
    >               reduce using rule 20 (expression -> IDENTIFIER .)
    <               reduce using rule 20 (expression -> IDENTIFIER .)
    ADD_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 20 (expression -> IDENTIFIER .)
    TO              reduce using rule 20 (expression -> IDENTIFIER .)
    {               reduce using rule 20 (expression -> IDENTIFIER .)
    }               reduce using rule 20 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 20 (expression -> IDENTIFIER .)
    PRINT           reduce using rule 20 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 20 (expression -> IDENTIFIER .)
    BOOL            reduce using rule 20 (expression -> IDENTIFIER .)
    NUMBER          reduce using rule 20 (expression -> IDENTIFIER .)
    TEXT            reduce using rule 20 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 20 (expression -> IDENTIFIER .)
    LOOP            reduce using rule 20 (expression -> IDENTIFIER .)
    FOR             reduce using rule 20 (expression -> IDENTIFIER .)
    IF              reduce using rule 20 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 20 (expression -> IDENTIFIER .)
    CASE            reduce using rule 20 (expression -> IDENTIFIER .)
    $end            reduce using rule 20 (expression -> IDENTIFIER .)
    )               reduce using rule 20 (expression -> IDENTIFIER .)
    STEP            reduce using rule 20 (expression -> IDENTIFIER .)


state 27

    (21) expression -> DIGIT .

    EQUAL           reduce using rule 21 (expression -> DIGIT .)
    NOTEQUAL        reduce using rule 21 (expression -> DIGIT .)
    >               reduce using rule 21 (expression -> DIGIT .)
    <               reduce using rule 21 (expression -> DIGIT .)
    ADD_OP          reduce using rule 21 (expression -> DIGIT .)
    MUL_OP          reduce using rule 21 (expression -> DIGIT .)
    TO              reduce using rule 21 (expression -> DIGIT .)
    {               reduce using rule 21 (expression -> DIGIT .)
    }               reduce using rule 21 (expression -> DIGIT .)
    BREAK           reduce using rule 21 (expression -> DIGIT .)
    PRINT           reduce using rule 21 (expression -> DIGIT .)
    IDENTIFIER      reduce using rule 21 (expression -> DIGIT .)
    BOOL            reduce using rule 21 (expression -> DIGIT .)
    NUMBER          reduce using rule 21 (expression -> DIGIT .)
    TEXT            reduce using rule 21 (expression -> DIGIT .)
    WHILE           reduce using rule 21 (expression -> DIGIT .)
    LOOP            reduce using rule 21 (expression -> DIGIT .)
    FOR             reduce using rule 21 (expression -> DIGIT .)
    IF              reduce using rule 21 (expression -> DIGIT .)
    SWITCH          reduce using rule 21 (expression -> DIGIT .)
    CASE            reduce using rule 21 (expression -> DIGIT .)
    $end            reduce using rule 21 (expression -> DIGIT .)
    )               reduce using rule 21 (expression -> DIGIT .)
    STEP            reduce using rule 21 (expression -> DIGIT .)


state 28

    (22) expression -> CHARACTERS .

    EQUAL           reduce using rule 22 (expression -> CHARACTERS .)
    NOTEQUAL        reduce using rule 22 (expression -> CHARACTERS .)
    >               reduce using rule 22 (expression -> CHARACTERS .)
    <               reduce using rule 22 (expression -> CHARACTERS .)
    ADD_OP          reduce using rule 22 (expression -> CHARACTERS .)
    MUL_OP          reduce using rule 22 (expression -> CHARACTERS .)
    TO              reduce using rule 22 (expression -> CHARACTERS .)
    {               reduce using rule 22 (expression -> CHARACTERS .)
    }               reduce using rule 22 (expression -> CHARACTERS .)
    BREAK           reduce using rule 22 (expression -> CHARACTERS .)
    PRINT           reduce using rule 22 (expression -> CHARACTERS .)
    IDENTIFIER      reduce using rule 22 (expression -> CHARACTERS .)
    BOOL            reduce using rule 22 (expression -> CHARACTERS .)
    NUMBER          reduce using rule 22 (expression -> CHARACTERS .)
    TEXT            reduce using rule 22 (expression -> CHARACTERS .)
    WHILE           reduce using rule 22 (expression -> CHARACTERS .)
    LOOP            reduce using rule 22 (expression -> CHARACTERS .)
    FOR             reduce using rule 22 (expression -> CHARACTERS .)
    IF              reduce using rule 22 (expression -> CHARACTERS .)
    SWITCH          reduce using rule 22 (expression -> CHARACTERS .)
    CASE            reduce using rule 22 (expression -> CHARACTERS .)
    $end            reduce using rule 22 (expression -> CHARACTERS .)
    )               reduce using rule 22 (expression -> CHARACTERS .)
    STEP            reduce using rule 22 (expression -> CHARACTERS .)


state 29

    (23) expression -> BOOLEAN .

    EQUAL           reduce using rule 23 (expression -> BOOLEAN .)
    NOTEQUAL        reduce using rule 23 (expression -> BOOLEAN .)
    >               reduce using rule 23 (expression -> BOOLEAN .)
    <               reduce using rule 23 (expression -> BOOLEAN .)
    ADD_OP          reduce using rule 23 (expression -> BOOLEAN .)
    MUL_OP          reduce using rule 23 (expression -> BOOLEAN .)
    TO              reduce using rule 23 (expression -> BOOLEAN .)
    {               reduce using rule 23 (expression -> BOOLEAN .)
    }               reduce using rule 23 (expression -> BOOLEAN .)
    BREAK           reduce using rule 23 (expression -> BOOLEAN .)
    PRINT           reduce using rule 23 (expression -> BOOLEAN .)
    IDENTIFIER      reduce using rule 23 (expression -> BOOLEAN .)
    BOOL            reduce using rule 23 (expression -> BOOLEAN .)
    NUMBER          reduce using rule 23 (expression -> BOOLEAN .)
    TEXT            reduce using rule 23 (expression -> BOOLEAN .)
    WHILE           reduce using rule 23 (expression -> BOOLEAN .)
    LOOP            reduce using rule 23 (expression -> BOOLEAN .)
    FOR             reduce using rule 23 (expression -> BOOLEAN .)
    IF              reduce using rule 23 (expression -> BOOLEAN .)
    SWITCH          reduce using rule 23 (expression -> BOOLEAN .)
    CASE            reduce using rule 23 (expression -> BOOLEAN .)
    $end            reduce using rule 23 (expression -> BOOLEAN .)
    )               reduce using rule 23 (expression -> BOOLEAN .)
    STEP            reduce using rule 23 (expression -> BOOLEAN .)


state 30

    (24) expression -> ( . expression )
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 49

state 31

    (12) structure -> LOOP { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 50
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 32

    (13) structure -> FOR expression . TO expression STEP expression { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    TO              shift and go to state 51
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 33

    (14) structure -> IF condition . { programme }
    (15) structure -> IF condition . { programme } ELSE { programme }

    {               shift and go to state 52


state 34

    (16) structure -> SWITCH expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               shift and go to state 53
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 35

    (17) structure -> CASE expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               shift and go to state 54
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 36

    (6) statement -> PRINT { expression . }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    }               shift and go to state 55
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 37

    (26) assignation -> IDENTIFIER = expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    BREAK           reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    PRINT           reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    IDENTIFIER      reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    BOOL            reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    NUMBER          reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    TEXT            reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    WHILE           reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    LOOP            reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    FOR             reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    IF              reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    SWITCH          reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    CASE            reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    $end            reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    }               reduce using rule 26 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 38

    (27) assignation -> BOOL IDENTIFIER = . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 56

state 39

    (28) assignation -> NUMBER IDENTIFIER = . DIGIT

    DIGIT           shift and go to state 57


state 40

    (29) assignation -> TEXT IDENTIFIER = . CHARACTERS

    CHARACTERS      shift and go to state 58


state 41

    (11) structure -> WHILE condition { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 59
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 42

    (7) condition -> expression EQUAL . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 60

state 43

    (8) condition -> expression NOTEQUAL . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 61

state 44

    (9) condition -> expression > . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 62

state 45

    (10) condition -> expression < . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 63

state 46

    (18) expression -> expression ADD_OP . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 64

state 47

    (19) expression -> expression MUL_OP . expression
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 65

state 48

    (25) expression -> ADD_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 25 (expression -> ADD_OP expression .)
    NOTEQUAL        reduce using rule 25 (expression -> ADD_OP expression .)
    >               reduce using rule 25 (expression -> ADD_OP expression .)
    <               reduce using rule 25 (expression -> ADD_OP expression .)
    ADD_OP          reduce using rule 25 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 25 (expression -> ADD_OP expression .)
    TO              reduce using rule 25 (expression -> ADD_OP expression .)
    {               reduce using rule 25 (expression -> ADD_OP expression .)
    }               reduce using rule 25 (expression -> ADD_OP expression .)
    BREAK           reduce using rule 25 (expression -> ADD_OP expression .)
    PRINT           reduce using rule 25 (expression -> ADD_OP expression .)
    IDENTIFIER      reduce using rule 25 (expression -> ADD_OP expression .)
    BOOL            reduce using rule 25 (expression -> ADD_OP expression .)
    NUMBER          reduce using rule 25 (expression -> ADD_OP expression .)
    TEXT            reduce using rule 25 (expression -> ADD_OP expression .)
    WHILE           reduce using rule 25 (expression -> ADD_OP expression .)
    LOOP            reduce using rule 25 (expression -> ADD_OP expression .)
    FOR             reduce using rule 25 (expression -> ADD_OP expression .)
    IF              reduce using rule 25 (expression -> ADD_OP expression .)
    SWITCH          reduce using rule 25 (expression -> ADD_OP expression .)
    CASE            reduce using rule 25 (expression -> ADD_OP expression .)
    $end            reduce using rule 25 (expression -> ADD_OP expression .)
    )               reduce using rule 25 (expression -> ADD_OP expression .)
    STEP            reduce using rule 25 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 46 ]
  ! MUL_OP          [ shift and go to state 47 ]


state 49

    (24) expression -> ( expression . )
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    )               shift and go to state 66
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 50

    (12) structure -> LOOP { programme . }

    }               shift and go to state 67


state 51

    (13) structure -> FOR expression TO . expression STEP expression { programme }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 68

state 52

    (14) structure -> IF condition { . programme }
    (15) structure -> IF condition { . programme } ELSE { programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 69
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 53

    (16) structure -> SWITCH expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 70
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 54

    (17) structure -> CASE expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 71
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 55

    (6) statement -> PRINT { expression } .

    BREAK           reduce using rule 6 (statement -> PRINT { expression } .)
    PRINT           reduce using rule 6 (statement -> PRINT { expression } .)
    IDENTIFIER      reduce using rule 6 (statement -> PRINT { expression } .)
    BOOL            reduce using rule 6 (statement -> PRINT { expression } .)
    NUMBER          reduce using rule 6 (statement -> PRINT { expression } .)
    TEXT            reduce using rule 6 (statement -> PRINT { expression } .)
    WHILE           reduce using rule 6 (statement -> PRINT { expression } .)
    LOOP            reduce using rule 6 (statement -> PRINT { expression } .)
    FOR             reduce using rule 6 (statement -> PRINT { expression } .)
    IF              reduce using rule 6 (statement -> PRINT { expression } .)
    SWITCH          reduce using rule 6 (statement -> PRINT { expression } .)
    CASE            reduce using rule 6 (statement -> PRINT { expression } .)
    $end            reduce using rule 6 (statement -> PRINT { expression } .)
    }               reduce using rule 6 (statement -> PRINT { expression } .)


state 56

    (27) assignation -> BOOL IDENTIFIER = expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    BREAK           reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    PRINT           reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    IDENTIFIER      reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    BOOL            reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    NUMBER          reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    TEXT            reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    WHILE           reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    LOOP            reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    FOR             reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    IF              reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    SWITCH          reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    CASE            reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    $end            reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    }               reduce using rule 27 (assignation -> BOOL IDENTIFIER = expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 57

    (28) assignation -> NUMBER IDENTIFIER = DIGIT .

    BREAK           reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    PRINT           reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    IDENTIFIER      reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    BOOL            reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    NUMBER          reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    TEXT            reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    WHILE           reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    LOOP            reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    FOR             reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    IF              reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    SWITCH          reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    CASE            reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    $end            reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)
    }               reduce using rule 28 (assignation -> NUMBER IDENTIFIER = DIGIT .)


state 58

    (29) assignation -> TEXT IDENTIFIER = CHARACTERS .

    BREAK           reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    PRINT           reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    IDENTIFIER      reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    BOOL            reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    NUMBER          reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    TEXT            reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    WHILE           reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    LOOP            reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    FOR             reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    IF              reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    SWITCH          reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    CASE            reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    $end            reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)
    }               reduce using rule 29 (assignation -> TEXT IDENTIFIER = CHARACTERS .)


state 59

    (11) structure -> WHILE condition { programme . }

    }               shift and go to state 72


state 60

    (7) condition -> expression EQUAL expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               reduce using rule 7 (condition -> expression EQUAL expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 61

    (8) condition -> expression NOTEQUAL expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               reduce using rule 8 (condition -> expression NOTEQUAL expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 62

    (9) condition -> expression > expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               reduce using rule 9 (condition -> expression > expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 63

    (10) condition -> expression < expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               reduce using rule 10 (condition -> expression < expression .)
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 64

    (18) expression -> expression ADD_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 18 (expression -> expression ADD_OP expression .)
    NOTEQUAL        reduce using rule 18 (expression -> expression ADD_OP expression .)
    >               reduce using rule 18 (expression -> expression ADD_OP expression .)
    <               reduce using rule 18 (expression -> expression ADD_OP expression .)
    ADD_OP          reduce using rule 18 (expression -> expression ADD_OP expression .)
    TO              reduce using rule 18 (expression -> expression ADD_OP expression .)
    {               reduce using rule 18 (expression -> expression ADD_OP expression .)
    }               reduce using rule 18 (expression -> expression ADD_OP expression .)
    BREAK           reduce using rule 18 (expression -> expression ADD_OP expression .)
    PRINT           reduce using rule 18 (expression -> expression ADD_OP expression .)
    IDENTIFIER      reduce using rule 18 (expression -> expression ADD_OP expression .)
    BOOL            reduce using rule 18 (expression -> expression ADD_OP expression .)
    NUMBER          reduce using rule 18 (expression -> expression ADD_OP expression .)
    TEXT            reduce using rule 18 (expression -> expression ADD_OP expression .)
    WHILE           reduce using rule 18 (expression -> expression ADD_OP expression .)
    LOOP            reduce using rule 18 (expression -> expression ADD_OP expression .)
    FOR             reduce using rule 18 (expression -> expression ADD_OP expression .)
    IF              reduce using rule 18 (expression -> expression ADD_OP expression .)
    SWITCH          reduce using rule 18 (expression -> expression ADD_OP expression .)
    CASE            reduce using rule 18 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 18 (expression -> expression ADD_OP expression .)
    )               reduce using rule 18 (expression -> expression ADD_OP expression .)
    STEP            reduce using rule 18 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 47

  ! MUL_OP          [ reduce using rule 18 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 46 ]


state 65

    (19) expression -> expression MUL_OP expression .
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    EQUAL           reduce using rule 19 (expression -> expression MUL_OP expression .)
    NOTEQUAL        reduce using rule 19 (expression -> expression MUL_OP expression .)
    >               reduce using rule 19 (expression -> expression MUL_OP expression .)
    <               reduce using rule 19 (expression -> expression MUL_OP expression .)
    ADD_OP          reduce using rule 19 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 19 (expression -> expression MUL_OP expression .)
    TO              reduce using rule 19 (expression -> expression MUL_OP expression .)
    {               reduce using rule 19 (expression -> expression MUL_OP expression .)
    }               reduce using rule 19 (expression -> expression MUL_OP expression .)
    BREAK           reduce using rule 19 (expression -> expression MUL_OP expression .)
    PRINT           reduce using rule 19 (expression -> expression MUL_OP expression .)
    IDENTIFIER      reduce using rule 19 (expression -> expression MUL_OP expression .)
    BOOL            reduce using rule 19 (expression -> expression MUL_OP expression .)
    NUMBER          reduce using rule 19 (expression -> expression MUL_OP expression .)
    TEXT            reduce using rule 19 (expression -> expression MUL_OP expression .)
    WHILE           reduce using rule 19 (expression -> expression MUL_OP expression .)
    LOOP            reduce using rule 19 (expression -> expression MUL_OP expression .)
    FOR             reduce using rule 19 (expression -> expression MUL_OP expression .)
    IF              reduce using rule 19 (expression -> expression MUL_OP expression .)
    SWITCH          reduce using rule 19 (expression -> expression MUL_OP expression .)
    CASE            reduce using rule 19 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 19 (expression -> expression MUL_OP expression .)
    )               reduce using rule 19 (expression -> expression MUL_OP expression .)
    STEP            reduce using rule 19 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 46 ]
  ! MUL_OP          [ shift and go to state 47 ]


state 66

    (24) expression -> ( expression ) .

    EQUAL           reduce using rule 24 (expression -> ( expression ) .)
    NOTEQUAL        reduce using rule 24 (expression -> ( expression ) .)
    >               reduce using rule 24 (expression -> ( expression ) .)
    <               reduce using rule 24 (expression -> ( expression ) .)
    ADD_OP          reduce using rule 24 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 24 (expression -> ( expression ) .)
    TO              reduce using rule 24 (expression -> ( expression ) .)
    {               reduce using rule 24 (expression -> ( expression ) .)
    }               reduce using rule 24 (expression -> ( expression ) .)
    BREAK           reduce using rule 24 (expression -> ( expression ) .)
    PRINT           reduce using rule 24 (expression -> ( expression ) .)
    IDENTIFIER      reduce using rule 24 (expression -> ( expression ) .)
    BOOL            reduce using rule 24 (expression -> ( expression ) .)
    NUMBER          reduce using rule 24 (expression -> ( expression ) .)
    TEXT            reduce using rule 24 (expression -> ( expression ) .)
    WHILE           reduce using rule 24 (expression -> ( expression ) .)
    LOOP            reduce using rule 24 (expression -> ( expression ) .)
    FOR             reduce using rule 24 (expression -> ( expression ) .)
    IF              reduce using rule 24 (expression -> ( expression ) .)
    SWITCH          reduce using rule 24 (expression -> ( expression ) .)
    CASE            reduce using rule 24 (expression -> ( expression ) .)
    $end            reduce using rule 24 (expression -> ( expression ) .)
    )               reduce using rule 24 (expression -> ( expression ) .)
    STEP            reduce using rule 24 (expression -> ( expression ) .)


state 67

    (12) structure -> LOOP { programme } .

    BREAK           reduce using rule 12 (structure -> LOOP { programme } .)
    PRINT           reduce using rule 12 (structure -> LOOP { programme } .)
    IDENTIFIER      reduce using rule 12 (structure -> LOOP { programme } .)
    BOOL            reduce using rule 12 (structure -> LOOP { programme } .)
    NUMBER          reduce using rule 12 (structure -> LOOP { programme } .)
    TEXT            reduce using rule 12 (structure -> LOOP { programme } .)
    WHILE           reduce using rule 12 (structure -> LOOP { programme } .)
    LOOP            reduce using rule 12 (structure -> LOOP { programme } .)
    FOR             reduce using rule 12 (structure -> LOOP { programme } .)
    IF              reduce using rule 12 (structure -> LOOP { programme } .)
    SWITCH          reduce using rule 12 (structure -> LOOP { programme } .)
    CASE            reduce using rule 12 (structure -> LOOP { programme } .)
    $end            reduce using rule 12 (structure -> LOOP { programme } .)
    }               reduce using rule 12 (structure -> LOOP { programme } .)


state 68

    (13) structure -> FOR expression TO expression . STEP expression { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    STEP            shift and go to state 73
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 69

    (14) structure -> IF condition { programme . }
    (15) structure -> IF condition { programme . } ELSE { programme }

    }               shift and go to state 74


state 70

    (16) structure -> SWITCH expression { programme . }

    }               shift and go to state 75


state 71

    (17) structure -> CASE expression { programme . }

    }               shift and go to state 76


state 72

    (11) structure -> WHILE condition { programme } .

    BREAK           reduce using rule 11 (structure -> WHILE condition { programme } .)
    PRINT           reduce using rule 11 (structure -> WHILE condition { programme } .)
    IDENTIFIER      reduce using rule 11 (structure -> WHILE condition { programme } .)
    BOOL            reduce using rule 11 (structure -> WHILE condition { programme } .)
    NUMBER          reduce using rule 11 (structure -> WHILE condition { programme } .)
    TEXT            reduce using rule 11 (structure -> WHILE condition { programme } .)
    WHILE           reduce using rule 11 (structure -> WHILE condition { programme } .)
    LOOP            reduce using rule 11 (structure -> WHILE condition { programme } .)
    FOR             reduce using rule 11 (structure -> WHILE condition { programme } .)
    IF              reduce using rule 11 (structure -> WHILE condition { programme } .)
    SWITCH          reduce using rule 11 (structure -> WHILE condition { programme } .)
    CASE            reduce using rule 11 (structure -> WHILE condition { programme } .)
    $end            reduce using rule 11 (structure -> WHILE condition { programme } .)
    }               reduce using rule 11 (structure -> WHILE condition { programme } .)


state 73

    (13) structure -> FOR expression TO expression STEP . expression { programme }
    (18) expression -> . expression ADD_OP expression
    (19) expression -> . expression MUL_OP expression
    (20) expression -> . IDENTIFIER
    (21) expression -> . DIGIT
    (22) expression -> . CHARACTERS
    (23) expression -> . BOOLEAN
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    IDENTIFIER      shift and go to state 26
    DIGIT           shift and go to state 27
    CHARACTERS      shift and go to state 28
    BOOLEAN         shift and go to state 29
    (               shift and go to state 30
    ADD_OP          shift and go to state 25

    expression                     shift and go to state 77

state 74

    (14) structure -> IF condition { programme } .
    (15) structure -> IF condition { programme } . ELSE { programme }

    BREAK           reduce using rule 14 (structure -> IF condition { programme } .)
    PRINT           reduce using rule 14 (structure -> IF condition { programme } .)
    IDENTIFIER      reduce using rule 14 (structure -> IF condition { programme } .)
    BOOL            reduce using rule 14 (structure -> IF condition { programme } .)
    NUMBER          reduce using rule 14 (structure -> IF condition { programme } .)
    TEXT            reduce using rule 14 (structure -> IF condition { programme } .)
    WHILE           reduce using rule 14 (structure -> IF condition { programme } .)
    LOOP            reduce using rule 14 (structure -> IF condition { programme } .)
    FOR             reduce using rule 14 (structure -> IF condition { programme } .)
    IF              reduce using rule 14 (structure -> IF condition { programme } .)
    SWITCH          reduce using rule 14 (structure -> IF condition { programme } .)
    CASE            reduce using rule 14 (structure -> IF condition { programme } .)
    $end            reduce using rule 14 (structure -> IF condition { programme } .)
    }               reduce using rule 14 (structure -> IF condition { programme } .)
    ELSE            shift and go to state 78


state 75

    (16) structure -> SWITCH expression { programme } .

    BREAK           reduce using rule 16 (structure -> SWITCH expression { programme } .)
    PRINT           reduce using rule 16 (structure -> SWITCH expression { programme } .)
    IDENTIFIER      reduce using rule 16 (structure -> SWITCH expression { programme } .)
    BOOL            reduce using rule 16 (structure -> SWITCH expression { programme } .)
    NUMBER          reduce using rule 16 (structure -> SWITCH expression { programme } .)
    TEXT            reduce using rule 16 (structure -> SWITCH expression { programme } .)
    WHILE           reduce using rule 16 (structure -> SWITCH expression { programme } .)
    LOOP            reduce using rule 16 (structure -> SWITCH expression { programme } .)
    FOR             reduce using rule 16 (structure -> SWITCH expression { programme } .)
    IF              reduce using rule 16 (structure -> SWITCH expression { programme } .)
    SWITCH          reduce using rule 16 (structure -> SWITCH expression { programme } .)
    CASE            reduce using rule 16 (structure -> SWITCH expression { programme } .)
    $end            reduce using rule 16 (structure -> SWITCH expression { programme } .)
    }               reduce using rule 16 (structure -> SWITCH expression { programme } .)


state 76

    (17) structure -> CASE expression { programme } .

    BREAK           reduce using rule 17 (structure -> CASE expression { programme } .)
    PRINT           reduce using rule 17 (structure -> CASE expression { programme } .)
    IDENTIFIER      reduce using rule 17 (structure -> CASE expression { programme } .)
    BOOL            reduce using rule 17 (structure -> CASE expression { programme } .)
    NUMBER          reduce using rule 17 (structure -> CASE expression { programme } .)
    TEXT            reduce using rule 17 (structure -> CASE expression { programme } .)
    WHILE           reduce using rule 17 (structure -> CASE expression { programme } .)
    LOOP            reduce using rule 17 (structure -> CASE expression { programme } .)
    FOR             reduce using rule 17 (structure -> CASE expression { programme } .)
    IF              reduce using rule 17 (structure -> CASE expression { programme } .)
    SWITCH          reduce using rule 17 (structure -> CASE expression { programme } .)
    CASE            reduce using rule 17 (structure -> CASE expression { programme } .)
    $end            reduce using rule 17 (structure -> CASE expression { programme } .)
    }               reduce using rule 17 (structure -> CASE expression { programme } .)


state 77

    (13) structure -> FOR expression TO expression STEP expression . { programme }
    (18) expression -> expression . ADD_OP expression
    (19) expression -> expression . MUL_OP expression

    {               shift and go to state 79
    ADD_OP          shift and go to state 46
    MUL_OP          shift and go to state 47


state 78

    (15) structure -> IF condition { programme } ELSE . { programme }

    {               shift and go to state 80


state 79

    (13) structure -> FOR expression TO expression STEP expression { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 81
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 80

    (15) structure -> IF condition { programme } ELSE { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . assignation
    (4) statement -> . structure
    (5) statement -> . BREAK
    (6) statement -> . PRINT { expression }
    (26) assignation -> . IDENTIFIER = expression
    (27) assignation -> . BOOL IDENTIFIER = expression
    (28) assignation -> . NUMBER IDENTIFIER = DIGIT
    (29) assignation -> . TEXT IDENTIFIER = CHARACTERS
    (11) structure -> . WHILE condition { programme }
    (12) structure -> . LOOP { programme }
    (13) structure -> . FOR expression TO expression STEP expression { programme }
    (14) structure -> . IF condition { programme }
    (15) structure -> . IF condition { programme } ELSE { programme }
    (16) structure -> . SWITCH expression { programme }
    (17) structure -> . CASE expression { programme }

    BREAK           shift and go to state 5
    PRINT           shift and go to state 6
    IDENTIFIER      shift and go to state 7
    BOOL            shift and go to state 8
    NUMBER          shift and go to state 9
    TEXT            shift and go to state 10
    WHILE           shift and go to state 11
    LOOP            shift and go to state 12
    FOR             shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    CASE            shift and go to state 16

    programme                      shift and go to state 82
    statement                      shift and go to state 2
    assignation                    shift and go to state 3
    structure                      shift and go to state 4

state 81

    (13) structure -> FOR expression TO expression STEP expression { programme . }

    }               shift and go to state 83


state 82

    (15) structure -> IF condition { programme } ELSE { programme . }

    }               shift and go to state 84


state 83

    (13) structure -> FOR expression TO expression STEP expression { programme } .

    BREAK           reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    PRINT           reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    IDENTIFIER      reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    BOOL            reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    NUMBER          reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    TEXT            reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    WHILE           reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    LOOP            reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    FOR             reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    IF              reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    SWITCH          reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    CASE            reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    $end            reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)
    }               reduce using rule 13 (structure -> FOR expression TO expression STEP expression { programme } .)


state 84

    (15) structure -> IF condition { programme } ELSE { programme } .

    BREAK           reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    PRINT           reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    IDENTIFIER      reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    BOOL            reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    NUMBER          reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    TEXT            reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    WHILE           reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    LOOP            reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    FOR             reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    IF              reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    SWITCH          reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    CASE            reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    $end            reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)
    }               reduce using rule 15 (structure -> IF condition { programme } ELSE { programme } .)

